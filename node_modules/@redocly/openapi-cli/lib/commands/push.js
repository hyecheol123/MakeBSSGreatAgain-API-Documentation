"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handlePush = void 0;
const fs = require("fs");
const path = require("path");
const node_fetch_1 = require("node-fetch");
const perf_hooks_1 = require("perf_hooks");
const colorette_1 = require("colorette");
const crypto_1 = require("crypto");
const openapi_core_1 = require("@redocly/openapi-core");
const utils_1 = require("../utils");
function handlePush(argv) {
    return __awaiter(this, void 0, void 0, function* () {
        const client = new openapi_core_1.RedoclyClient();
        const isAuthorized = yield client.isAuthorizedWithRedocly();
        if (!isAuthorized) {
            const clientToken = yield utils_1.promptUser(colorette_1.green(`\n  ðŸ”‘ Copy your access token from ${colorette_1.blue('https://app.redoc.ly/profile')} and paste it below`));
            yield client.login(clientToken);
        }
        const startedAt = perf_hooks_1.performance.now();
        const { entrypoint, destination, branchName, upsert } = argv;
        if (!validateDestination(destination)) {
            utils_1.exitWithError(`Destination argument value is not valid, please use the right format: ${colorette_1.yellow('<@organization-id/api-name@api-version>')}`);
        }
        const [organizationId, apiName, apiVersion] = getDestinationProps(destination);
        yield doesOrganizationExist(organizationId);
        const { version } = yield client.getDefinitionVersion(organizationId, apiName, apiVersion);
        if (!version && !upsert) {
            utils_1.exitWithError(`
  The definition version ${colorette_1.blue(apiName)}/${colorette_1.blue(apiVersion)} does not exist in organization ${colorette_1.blue(organizationId)}!
  ${colorette_1.yellow('Suggestion:')} please use ${colorette_1.blue('-u')} or ${colorette_1.blue('--upsert')} to create definition.
    `);
        }
        if (version) {
            const { definitionId, defaultBranch, id } = version;
            const updatePatch = yield collectAndUploadFiles(branchName || defaultBranch.name);
            yield client.updateDefinitionVersion(definitionId, id, updatePatch);
        }
        else if (upsert) {
            yield doesOrganizationExist(organizationId);
            const { definition } = yield client.getDefinitionByName(apiName, organizationId);
            let definitionId;
            if (!definition) {
                const { def } = yield client.createDefinition(organizationId, apiName);
                definitionId = def.definition.id;
            }
            else {
                definitionId = definition.id;
            }
            const updatePatch = yield collectAndUploadFiles(branchName || 'main');
            yield client.createDefinitionVersion(definitionId, apiVersion, "FILE", updatePatch.source);
        }
        process.stderr.write(`Definition: ${colorette_1.blue(entrypoint)} is successfully pushed to Redocly API Registry \n`);
        utils_1.printExecutionTime('push', startedAt, entrypoint);
        function doesOrganizationExist(organizationId) {
            return __awaiter(this, void 0, void 0, function* () {
                const { organizationById } = yield client.getOrganizationId(organizationId);
                if (!organizationById) {
                    utils_1.exitWithError(`Organization ${colorette_1.blue(organizationId)} not found`);
                }
            });
        }
        function collectAndUploadFiles(branch) {
            return __awaiter(this, void 0, void 0, function* () {
                let source = { files: [], branchName: branch };
                const filesToUpload = yield collectFilesToUpload(entrypoint);
                const filesHash = hashFiles(filesToUpload.files);
                process.stdout.write(`Uploading ${filesToUpload.files.length} ${utils_1.pluralize('file', filesToUpload.files.length)}:\n`);
                let uploaded = 0;
                for (let file of filesToUpload.files) {
                    const { signFileUploadCLI } = yield client.getSignedUrl(organizationId, filesHash, file.keyOnS3);
                    const { signedFileUrl, uploadedFilePath } = signFileUploadCLI;
                    if (file.filePath === filesToUpload.root) {
                        source['root'] = uploadedFilePath;
                    }
                    source.files.push(uploadedFilePath);
                    process.stdout.write(`Uploading ${file.contents ? 'bundle for ' : ''}${colorette_1.blue(file.filePath)}...`);
                    yield uploadFileToS3(signedFileUrl, file.contents || file.filePath);
                    process.stdout.write(colorette_1.green(`âœ“ (${++uploaded}/${filesToUpload.files.length})\n`));
                }
                process.stdout.write('\n');
                return {
                    sourceType: "FILE",
                    source: JSON.stringify(source)
                };
            });
        }
    });
}
exports.handlePush = handlePush;
function getFilesList(dir, files) {
    files = files || [];
    const filesAndDirs = fs.readdirSync(dir);
    for (const name of filesAndDirs) {
        if (fs.statSync(path.join(dir, name)).isDirectory()) {
            files = getFilesList(path.join(dir, name), files);
        }
        else {
            const currentPath = dir + '/' + name;
            files.push(currentPath);
        }
    }
    return files;
}
function collectFilesToUpload(entrypoint) {
    return __awaiter(this, void 0, void 0, function* () {
        let files = [];
        const config = yield openapi_core_1.loadConfig();
        const entrypoints = yield utils_1.getFallbackEntryPointsOrExit([entrypoint], config);
        const entrypointPath = entrypoints[0];
        process.stdout.write('Bundling definition\n');
        const { bundle: openapiBundle, problems } = yield openapi_core_1.bundle({
            config,
            ref: entrypointPath
        });
        const fileTotals = utils_1.getTotals(problems);
        if (fileTotals.errors === 0) {
            process.stdout.write(`Created a bundle for ${colorette_1.blue(entrypoint)} ${fileTotals.warnings > 0 ? 'with warnings' : ''}\n`);
        }
        else {
            utils_1.exitWithError(`Failed to create a bundle for ${colorette_1.blue(entrypoint)}\n`);
        }
        const fileExt = path.extname(entrypointPath).split('.').pop();
        files.push(getFileEntry(entrypointPath, utils_1.dumpBundle(openapiBundle.parsed, fileExt)));
        if (fs.existsSync('package.json')) {
            files.push(getFileEntry('package.json'));
        }
        if (fs.existsSync(openapi_core_1.IGNORE_FILE)) {
            files.push(getFileEntry(openapi_core_1.IGNORE_FILE));
        }
        if (config.configFile) {
            files.push(getFileEntry(config.configFile));
            if (config.referenceDocs.htmlTemplate) {
                const dir = getFolder(config.referenceDocs.htmlTemplate);
                const fileList = getFilesList(dir, []);
                files.push(...fileList.map(f => getFileEntry(f)));
            }
            if (config.rawConfig && config.rawConfig.lint && config.rawConfig.lint.plugins) {
                let pluginFiles = new Set();
                for (const plugin of config.rawConfig.lint.plugins) {
                    if (typeof plugin !== 'string')
                        continue;
                    const fileList = getFilesList(getFolder(plugin), []);
                    fileList.forEach(f => pluginFiles.add(f));
                }
                files.push(...(filterPluginFilesByExt(Array.from(pluginFiles))).map(f => getFileEntry(f)));
            }
        }
        return {
            files,
            root: path.resolve(entrypointPath),
        };
        function filterPluginFilesByExt(files) {
            return files.filter((file) => {
                const fileExt = path.extname(file).toLowerCase();
                return fileExt === '.js' || fileExt === '.ts' || fileExt === '.mjs' || fileExt === 'json';
            });
        }
        function getFileEntry(filename, contents) {
            return {
                filePath: path.resolve(filename),
                keyOnS3: config.configFile
                    ? utils_1.slash(path.relative(path.dirname(config.configFile), filename))
                    : utils_1.slash(path.basename(filename)),
                contents: contents && Buffer.from(contents, 'utf-8') || undefined,
            };
        }
    });
}
function getFolder(filePath) {
    return path.resolve(path.dirname(filePath));
}
function hashFiles(filePaths) {
    let sum = crypto_1.createHash('sha256');
    filePaths.forEach(file => sum.update(fs.readFileSync(file.filePath)));
    return sum.digest('hex');
}
function validateDestination(destination) {
    const regexp = /^@+[a-zA-Z0-9-_.& ]+\/+[^@\/]+@[^@\/]+$/g;
    return regexp.test(destination);
}
function getDestinationProps(destination) {
    return destination.substring(1).split(/[@\/]/);
}
function uploadFileToS3(url, filePathOrBuffer) {
    const fileSizeInBytes = typeof filePathOrBuffer === 'string' ? fs.statSync(filePathOrBuffer).size : filePathOrBuffer.byteLength;
    let readStream = typeof filePathOrBuffer === 'string' ? fs.createReadStream(filePathOrBuffer) : filePathOrBuffer;
    return node_fetch_1.default(url, {
        method: 'PUT',
        headers: {
            'Content-Length': fileSizeInBytes.toString()
        },
        body: readStream
    });
}

"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleSplit = void 0;
const colorette_1 = require("colorette");
const fs = require("fs");
const yaml = require("js-yaml");
const path = require("path");
const perf_hooks_1 = require("perf_hooks");
const isEqual = require('lodash.isequal');
const utils_1 = require("../../utils");
const js_utils_1 = require("../../js-utils");
const types_1 = require("./types");
function handleSplit(argv) {
    return __awaiter(this, void 0, void 0, function* () {
        const startedAt = perf_hooks_1.performance.now();
        const { entrypoint, outDir } = argv;
        validateDefinitionFileName(entrypoint);
        const openapi = utils_1.readYaml(entrypoint);
        splitDefinition(openapi, outDir);
        process.stderr.write(`ðŸª“ Document: ${colorette_1.blue(entrypoint)} ${colorette_1.green('is successfully split')}
    and all related files are saved to the directory: ${colorette_1.blue(outDir)} \n`);
        utils_1.printExecutionTime('split', startedAt, entrypoint);
    });
}
exports.handleSplit = handleSplit;
function splitDefinition(openapi, openapiDir) {
    fs.mkdirSync(openapiDir, { recursive: true });
    const pathsDir = path.join(openapiDir, types_1.PATHS);
    fs.mkdirSync(pathsDir, { recursive: true });
    const componentsFiles = {};
    iteratePaths(openapi, pathsDir, openapiDir);
    iterateComponents(openapi, openapiDir, componentsFiles);
    function traverseDirectoryDeepCallback(filename, directory) {
        if (isNotYaml(filename))
            return;
        const pathData = utils_1.readYaml(filename);
        replace$Refs(pathData, directory, componentsFiles);
        utils_1.writeYaml(pathData, filename);
    }
    traverseDirectoryDeep(pathsDir, traverseDirectoryDeepCallback);
    replace$Refs(openapi, openapiDir, componentsFiles);
    utils_1.writeYaml(openapi, path.join(openapiDir, 'openapi.yaml'));
}
function isStartsWithComponents(node) {
    return node.startsWith(types_1.componentsPath);
}
function isNotYaml(filename) {
    return !(filename.endsWith('.yaml') || filename.endsWith('.yml'));
}
function loadFile(fileName) {
    try {
        return yaml.safeLoad(fs.readFileSync(fileName, 'utf8'));
    }
    catch (e) {
        return utils_1.exitWithError(e.message);
    }
}
function validateDefinitionFileName(fileName) {
    if (!fs.existsSync(fileName))
        utils_1.exitWithError(`File ${colorette_1.blue(fileName)} does not exist \n`);
    const file = loadFile(fileName);
    if (file.swagger)
        utils_1.exitWithError('OpenAPI 2 is not supported by this command');
    if (!file.openapi)
        utils_1.exitWithError('File does not conform to the OpenAPI Specification. OpenAPI version is not specified');
    return true;
}
function langToExt(lang) {
    const langObj = {
        php: '.php',
        'c#': '.cs',
        shell: '.sh',
        curl: '.sh',
        bash: '.sh',
        javascript: '.js',
        js: '.js',
        python: '.py'
    };
    return langObj[lang];
}
function traverseDirectoryDeep(directory, callback) {
    if (!fs.existsSync(directory) || !fs.statSync(directory).isDirectory())
        return;
    const files = fs.readdirSync(directory);
    for (const f of files) {
        const filename = path.join(directory, f);
        if (fs.statSync(filename).isDirectory()) {
            traverseDirectoryDeep(filename, callback);
        }
        else {
            callback(filename, directory);
        }
    }
}
function crawl(object, visitor) {
    if (!js_utils_1.isObject(object))
        return;
    for (const key of Object.keys(object)) {
        visitor(object, key);
        crawl(object[key], visitor);
    }
}
function replace$Refs(obj, relativeFrom, componentFiles = {}) {
    crawl(obj, (node) => {
        if (node.$ref && js_utils_1.isString(node.$ref) && isStartsWithComponents(node.$ref)) {
            replace(node, '$ref');
        }
        else if (node.discriminator &&
            node.discriminator.mapping &&
            js_utils_1.isObject(node.discriminator.mapping)) {
            const { mapping } = node.discriminator;
            for (const name of Object.keys(mapping)) {
                if (js_utils_1.isString(mapping[name]) && isStartsWithComponents(mapping[name])) {
                    replace(node.discriminator.mapping, name);
                }
            }
        }
    });
    function replace(node, key) {
        const splittedNode = node[key].split('/');
        const name = splittedNode.pop();
        const groupName = splittedNode[2];
        const filesGroupName = componentFiles[groupName];
        if (!filesGroupName || !filesGroupName[name])
            return;
        let filename = path.relative(relativeFrom, filesGroupName[name].filename);
        if (!filename.startsWith('.')) {
            filename = '.' + path.sep + filename;
        }
        node[key] = filename;
    }
}
function implicitlyReferenceDiscriminator(obj, defName, filename, schemaFiles) {
    if (!obj.discriminator)
        return;
    const defPtr = `#/${types_1.COMPONENTS}/${types_1.OPENAPI3_COMPONENT.Schemas}/${defName}`;
    const implicitMapping = {};
    for (const [name, { inherits, filename: parentFilename }] of Object.entries(schemaFiles)) {
        if (inherits.indexOf(defPtr) > -1) {
            const res = path.relative(path.dirname(filename), parentFilename);
            implicitMapping[name] = res.startsWith('.') ? res : '.' + path.sep + res;
        }
    }
    if (js_utils_1.isEmptyObject(implicitMapping))
        return;
    const discriminatorPropSchema = obj.properties[obj.discriminator.propertyName];
    const discriminatorEnum = discriminatorPropSchema && discriminatorPropSchema.enum;
    const mapping = (obj.discriminator.mapping = obj.discriminator.mapping || {});
    for (const name of Object.keys(implicitMapping)) {
        if (discriminatorEnum && !discriminatorEnum.includes(name)) {
            continue;
        }
        if (mapping[name] && mapping[name] !== implicitMapping[name]) {
            process.stderr.write(colorette_1.yellow(`warning: explicit mapping overlaps with local mapping entry ${colorette_1.red(name)} at ${colorette_1.blue(filename)}. Please check it.`));
        }
        mapping[name] = implicitMapping[name];
    }
}
function isNotSecurityComponentType(componentType) {
    return componentType !== types_1.OPENAPI3_COMPONENT.SecuritySchemes;
}
function findComponentTypes(components) {
    return types_1.OPENAPI3_COMPONENT_NAMES
        .filter(item => isNotSecurityComponentType(item) && Object.keys(components).includes(item));
}
function doesFileDiffer(filename, componentData) {
    return fs.existsSync(filename) && !isEqual(utils_1.readYaml(filename), componentData);
}
function removeEmptyComponents(openapi, componentType) {
    if (openapi.components && js_utils_1.isEmptyObject(openapi.components[componentType])) {
        delete openapi.components[componentType];
    }
    if (js_utils_1.isEmptyObject(openapi.components)) {
        delete openapi.components;
    }
}
function createComponentDir(componentDirPath, componentType) {
    if (isNotSecurityComponentType(componentType)) {
        fs.mkdirSync(componentDirPath, { recursive: true });
    }
}
function extractFileNameFromPath(filename) {
    return path.basename(filename, path.extname(filename));
}
function getFileNamePath(componentDirPath, componentName) {
    return path.join(componentDirPath, componentName) + '.yaml';
}
function gatherComponentsFiles(components, componentsFiles, componentType, componentName, filename) {
    var _a, _b;
    let inherits = [];
    if (componentType === types_1.OPENAPI3_COMPONENT.Schemas) {
        inherits = (((_b = (_a = components === null || components === void 0 ? void 0 : components[componentType]) === null || _a === void 0 ? void 0 : _a[componentName]) === null || _b === void 0 ? void 0 : _b.allOf) || []).map((s) => s.$ref).filter(Boolean);
    }
    componentsFiles[componentType] = componentsFiles[componentType] || {};
    componentsFiles[componentType][componentName] = { inherits, filename };
}
function iteratePaths(openapi, pathsDir, openapiDir) {
    const { paths } = openapi;
    if (paths) {
        for (const oasPath of Object.keys(paths)) {
            const pathFile = path.join(pathsDir, utils_1.pathToFilename(oasPath)) + '.yaml';
            const pathData = paths[oasPath];
            for (const method of types_1.OPENAPI3_METHOD_NAMES) {
                const methodData = pathData[method];
                const methodDataXCode = (methodData === null || methodData === void 0 ? void 0 : methodData['x-code-samples']) || (methodData === null || methodData === void 0 ? void 0 : methodData['x-codeSamples']);
                if (!methodDataXCode || !Array.isArray(methodDataXCode)) {
                    continue;
                }
                for (const sample of methodDataXCode) {
                    if (sample.source && sample.source.$ref)
                        continue;
                    const sampleFileName = path.join(openapiDir, 'code_samples', sample.lang, utils_1.pathToFilename(oasPath), method + langToExt(sample.lang));
                    fs.mkdirSync(path.dirname(sampleFileName), { recursive: true });
                    fs.writeFileSync(sampleFileName, sample.source);
                    // @ts-ignore
                    sample.source = {
                        $ref: path.relative(pathsDir, sampleFileName)
                    };
                }
            }
            utils_1.writeYaml(pathData, pathFile);
            paths[oasPath] = {
                $ref: path.relative(openapiDir, pathFile)
            };
        }
    }
}
function iterateComponents(openapi, openapiDir, componentsFiles) {
    const { components } = openapi;
    if (components) {
        const componentsDir = path.join(openapiDir, types_1.COMPONENTS);
        fs.mkdirSync(componentsDir, { recursive: true });
        const componentTypes = findComponentTypes(components);
        componentTypes.forEach(iterateAndGatherComponentsFiles);
        componentTypes.forEach(iterateComponentTypes);
        function iterateAndGatherComponentsFiles(componentType) {
            const componentDirPath = path.join(componentsDir, componentType);
            for (const componentName of Object.keys((components === null || components === void 0 ? void 0 : components[componentType]) || {})) {
                const filename = getFileNamePath(componentDirPath, componentName);
                gatherComponentsFiles(components, componentsFiles, componentType, componentName, filename);
            }
        }
        function iterateComponentTypes(componentType) {
            var _a, _b, _c;
            const componentDirPath = path.join(componentsDir, componentType);
            createComponentDir(componentDirPath, componentType);
            for (const componentName of Object.keys((components === null || components === void 0 ? void 0 : components[componentType]) || {})) {
                const filename = getFileNamePath(componentDirPath, componentName);
                const componentData = (_a = components === null || components === void 0 ? void 0 : components[componentType]) === null || _a === void 0 ? void 0 : _a[componentName];
                replace$Refs(componentData, path.dirname(filename), componentsFiles);
                implicitlyReferenceDiscriminator(componentData, extractFileNameFromPath(filename), filename, componentsFiles.schemas || {});
                if (doesFileDiffer(filename, componentData)) {
                    process.stderr.write(colorette_1.yellow(`warning: conflict for ${componentName} - file already exists with different content: ${colorette_1.blue(filename)} ... Skip.\n`));
                }
                else {
                    utils_1.writeYaml(componentData, filename);
                }
                if (isNotSecurityComponentType(componentType)) {
                    // security schemas must referenced from components
                    (_c = (_b = openapi.components) === null || _b === void 0 ? void 0 : _b[componentType]) === null || _c === void 0 ? true : delete _c[componentName];
                }
            }
            removeEmptyComponents(openapi, componentType);
        }
    }
}

"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleJoin = void 0;
const path = require("path");
const colorette_1 = require("colorette");
const perf_hooks_1 = require("perf_hooks");
const isEqual = require('lodash.isequal');
const openapi_core_1 = require("@redocly/openapi-core");
const utils_1 = require("../utils");
const js_utils_1 = require("../js-utils");
const COMPONENTS = 'components';
let potentialConflictsTotal = 0;
function handleJoin(argv, packageVersion) {
    return __awaiter(this, void 0, void 0, function* () {
        const startedAt = perf_hooks_1.performance.now();
        if (argv.entrypoints.length < 2) {
            return utils_1.exitWithError(`At least 2 entrypoints should be provided. \n\n`);
        }
        const config = yield openapi_core_1.loadConfig();
        const entrypoints = yield utils_1.getFallbackEntryPointsOrExit(argv.entrypoints, config);
        const externalRefResolver = new openapi_core_1.BaseResolver(config.resolve);
        const documents = yield Promise.all(entrypoints.map(ref => externalRefResolver.resolveDocument(null, ref)));
        for (const document of documents) {
            try {
                const version = openapi_core_1.detectOpenAPI(document.parsed);
                if (version !== openapi_core_1.OasVersion.Version3_0) {
                    return utils_1.exitWithError(`Only OpenAPI 3 is supported: ${colorette_1.blue(document.source.absoluteRef)} \n\n`);
                }
            }
            catch (e) {
                return utils_1.exitWithError(`${e.message}: ${colorette_1.blue(document.source.absoluteRef)}`);
            }
        }
        if (argv.lint) {
            for (const document of documents) {
                yield validateEntrypoint(document, config.lint, externalRefResolver, packageVersion);
            }
        }
        let joinedDef = {};
        let potentialConflicts = {
            tags: {},
            paths: {},
            components: {},
            xWebhooks: {}
        };
        const prefixComponentsWithInfoProp = argv['prefix-components-with-info-prop'];
        const prefixTagsWithFilename = argv['prefix-tags-with-filename'];
        const prefixTagsWithInfoProp = argv['prefix-tags-with-info-prop'];
        if (prefixTagsWithFilename && prefixTagsWithInfoProp) {
            return utils_1.exitWithError(`You used ${colorette_1.yellow('prefix-tags-with-filename')} and ${colorette_1.yellow('prefix-tags-with-info-prop')} that do not go together.\nPlease choose only one! \n\n`);
        }
        addInfoSectionAndSpecVersion(documents, prefixComponentsWithInfoProp);
        for (const document of documents) {
            const openapi = document.parsed;
            const { tags, info } = openapi;
            const entrypoint = path.relative(process.cwd(), document.source.absoluteRef);
            const entrypointFilename = getEntrypointFilename(entrypoint);
            const tagsPrefix = prefixTagsWithFilename ? entrypointFilename : getInfoPrefix(info, prefixTagsWithInfoProp, 'tags');
            const componentsPrefix = getInfoPrefix(info, prefixComponentsWithInfoProp, COMPONENTS);
            if (openapi.hasOwnProperty('x-tagGroups')) {
                process.stderr.write(colorette_1.yellow(`warning: x-tagGroups at ${colorette_1.blue(entrypoint)} will be skipped \n`));
            }
            const context = { entrypoint, entrypointFilename, tags, potentialConflicts, tagsPrefix, componentsPrefix };
            if (tags) {
                populateTags(context);
            }
            collectServers(openapi);
            collectInfoDescriptions(openapi, context);
            collectExternalDocs(openapi, context);
            collectPaths(openapi, context);
            collectComponents(openapi, context);
            collectXWebhooks(openapi, context);
            if (componentsPrefix) {
                replace$Refs(openapi, componentsPrefix);
            }
        }
        iteratePotentialConflicts(potentialConflicts);
        const specFilename = 'openapi.yaml';
        const noRefs = true;
        if (!potentialConflictsTotal) {
            utils_1.writeYaml(joinedDef, specFilename, noRefs);
        }
        utils_1.printExecutionTime('join', startedAt, specFilename);
        function populateTags({ entrypoint, entrypointFilename, tags, potentialConflicts, tagsPrefix, componentsPrefix }) {
            const xTagGroups = 'x-tagGroups';
            const Tags = 'tags';
            if (!joinedDef.hasOwnProperty(Tags)) {
                joinedDef[Tags] = [];
            }
            if (!joinedDef.hasOwnProperty(xTagGroups)) {
                joinedDef[xTagGroups] = [];
            }
            if (!potentialConflicts.tags.hasOwnProperty('all')) {
                potentialConflicts.tags['all'] = {};
            }
            if (!joinedDef[xTagGroups].some((g) => g.name === entrypointFilename)) {
                joinedDef[xTagGroups].push({ name: entrypointFilename, tags: [] });
            }
            const indexGroup = joinedDef[xTagGroups].findIndex((item) => item.name === entrypointFilename);
            if (!joinedDef[xTagGroups][indexGroup].hasOwnProperty(Tags)) {
                joinedDef[xTagGroups][indexGroup][Tags] = [];
            }
            for (const tag of tags) {
                const entrypointTagName = addPrefix(tag.name, tagsPrefix);
                if (tag.description) {
                    tag.description = addComponentsPrefix(tag.description, componentsPrefix);
                }
                if (!joinedDef.tags.find((t) => t.name === entrypointTagName)) {
                    tag['x-displayName'] = tag.name;
                    tag.name = entrypointTagName;
                    joinedDef.tags.push(tag);
                }
                if (!joinedDef[xTagGroups][indexGroup][Tags].find((t) => t === entrypointTagName)) {
                    joinedDef[xTagGroups][indexGroup][Tags].push(entrypointTagName);
                }
                const doesEntrypointExist = !potentialConflicts.tags.all[entrypointTagName] || (potentialConflicts.tags.all[entrypointTagName] &&
                    !potentialConflicts.tags.all[entrypointTagName].includes(entrypoint));
                potentialConflicts.tags.all[entrypointTagName] = [
                    ...(potentialConflicts.tags.all[entrypointTagName] || []), ...(doesEntrypointExist ? [entrypoint] : [])
                ];
            }
        }
        function collectServers(openapi) {
            const { servers } = openapi;
            if (servers) {
                if (!joinedDef.hasOwnProperty('servers')) {
                    joinedDef['servers'] = [];
                }
                for (const server of servers) {
                    if (!joinedDef.servers.some((s) => s.url === server.url)) {
                        joinedDef.servers.push(server);
                    }
                }
            }
        }
        function collectInfoDescriptions(openapi, { entrypointFilename, componentsPrefix }) {
            const { info } = openapi;
            if (info && info.description) {
                const xTagGroups = 'x-tagGroups';
                const groupIndex = joinedDef[xTagGroups] ? joinedDef[xTagGroups].findIndex((item) => item.name === entrypointFilename) : -1;
                if (joinedDef.hasOwnProperty(xTagGroups) &&
                    groupIndex !== -1 &&
                    joinedDef[xTagGroups][groupIndex]['tags'] &&
                    joinedDef[xTagGroups][groupIndex]['tags'].length) {
                    joinedDef[xTagGroups][groupIndex]['description'] = addComponentsPrefix(info.description, componentsPrefix);
                }
            }
        }
        function collectExternalDocs(openapi, { entrypoint }) {
            const { externalDocs } = openapi;
            if (externalDocs) {
                if (joinedDef.hasOwnProperty('externalDocs')) {
                    process.stderr.write(colorette_1.yellow(`warning: skip externalDocs from ${colorette_1.blue(path.basename(entrypoint))} \n`));
                    return;
                }
                joinedDef['externalDocs'] = externalDocs;
            }
        }
        function collectPaths(openapi, { entrypointFilename, entrypoint, potentialConflicts, tagsPrefix, componentsPrefix }) {
            const { paths } = openapi;
            if (paths) {
                if (!joinedDef.hasOwnProperty('paths')) {
                    joinedDef['paths'] = {};
                }
                for (const path of Object.keys(paths)) {
                    if (!joinedDef.paths.hasOwnProperty(path)) {
                        joinedDef.paths[path] = {};
                    }
                    if (!potentialConflicts.paths.hasOwnProperty(path)) {
                        potentialConflicts.paths[path] = {};
                    }
                    for (const operation of Object.keys(paths[path])) {
                        // @ts-ignore
                        const pathOperation = paths[path][operation];
                        joinedDef.paths[path][operation] = pathOperation;
                        potentialConflicts.paths[path][operation] = [...(potentialConflicts.paths[path][operation] || []), entrypoint];
                        const { operationId } = pathOperation;
                        if (operationId) {
                            if (!potentialConflicts.paths.hasOwnProperty('operationIds')) {
                                potentialConflicts.paths['operationIds'] = {};
                            }
                            potentialConflicts.paths.operationIds[operationId] = [...(potentialConflicts.paths.operationIds[operationId] || []), entrypoint];
                        }
                        let { tags, security } = joinedDef.paths[path][operation];
                        if (tags) {
                            joinedDef.paths[path][operation].tags = tags.map((tag) => addPrefix(tag, tagsPrefix));
                            populateTags({ entrypoint, entrypointFilename, tags: formatTags(tags), potentialConflicts, tagsPrefix, componentsPrefix });
                        }
                        else {
                            joinedDef.paths[path][operation]['tags'] = [addPrefix('other', tagsPrefix || entrypointFilename)];
                            populateTags({ entrypoint, entrypointFilename, tags: formatTags(['other']), potentialConflicts, tagsPrefix: tagsPrefix || entrypointFilename, componentsPrefix });
                        }
                        if (!security && openapi.hasOwnProperty('security')) {
                            joinedDef.paths[path][operation]['security'] = addSecurityPrefix(openapi.security, componentsPrefix);
                        }
                        else if (pathOperation.security) {
                            joinedDef.paths[path][operation].security = addSecurityPrefix(pathOperation.security, componentsPrefix);
                        }
                    }
                }
            }
        }
        function collectComponents(openapi, { entrypoint, potentialConflicts, componentsPrefix }) {
            const { components } = openapi;
            if (components) {
                if (!joinedDef.hasOwnProperty(COMPONENTS)) {
                    joinedDef[COMPONENTS] = {};
                }
                for (const component of Object.keys(components)) {
                    if (!potentialConflicts[COMPONENTS].hasOwnProperty(component)) {
                        potentialConflicts[COMPONENTS][component] = {};
                        joinedDef[COMPONENTS][component] = {};
                    }
                    // @ts-ignore
                    const componentObj = components[component];
                    for (const item of Object.keys(componentObj)) {
                        const componentPrefix = addPrefix(item, componentsPrefix);
                        potentialConflicts.components[component][componentPrefix] = [
                            ...(potentialConflicts.components[component][item] || []), { [entrypoint]: componentObj[item] }
                        ];
                        joinedDef.components[component][componentPrefix] = componentObj[item];
                    }
                }
            }
        }
        function collectXWebhooks(openapi, { entrypointFilename, entrypoint, potentialConflicts, tagsPrefix, componentsPrefix }) {
            const xWebhooks = 'x-webhooks';
            // @ts-ignore
            const openapiXWebhooks = openapi[xWebhooks];
            if (openapiXWebhooks) {
                if (!joinedDef.hasOwnProperty(xWebhooks)) {
                    joinedDef[xWebhooks] = {};
                }
                for (const webhook of Object.keys(openapiXWebhooks)) {
                    joinedDef[xWebhooks][webhook] = openapiXWebhooks[webhook];
                    if (!potentialConflicts.xWebhooks.hasOwnProperty(webhook)) {
                        potentialConflicts.xWebhooks[webhook] = {};
                    }
                    for (const operation of Object.keys(openapiXWebhooks[webhook])) {
                        potentialConflicts.xWebhooks[webhook][operation] = [...(potentialConflicts.xWebhooks[webhook][operation] || []), entrypoint];
                    }
                    for (const operationKey of Object.keys(joinedDef[xWebhooks][webhook])) {
                        let { tags } = joinedDef[xWebhooks][webhook][operationKey];
                        if (tags) {
                            joinedDef[xWebhooks][webhook][operationKey].tags = tags.map((tag) => addPrefix(tag, tagsPrefix));
                            populateTags({ entrypoint, entrypointFilename, tags: formatTags(tags), potentialConflicts, tagsPrefix, componentsPrefix });
                        }
                    }
                }
            }
        }
        function addInfoSectionAndSpecVersion(documents, prefixComponentsWithInfoProp) {
            var _a;
            const firstEntrypoint = documents[0];
            const openapi = firstEntrypoint.parsed;
            const componentsPrefix = getInfoPrefix(openapi.info, prefixComponentsWithInfoProp, COMPONENTS);
            if (!openapi.openapi)
                utils_1.exitWithError('Version of specification is not found in. \n');
            if (!openapi.info)
                utils_1.exitWithError('Info section is not found in specification. \n');
            if ((_a = openapi.info) === null || _a === void 0 ? void 0 : _a.description) {
                openapi.info.description = addComponentsPrefix(openapi.info.description, componentsPrefix);
            }
            joinedDef.openapi = openapi.openapi;
            joinedDef.info = openapi.info;
        }
    });
}
exports.handleJoin = handleJoin;
function doesComponentsDiffer(curr, next) {
    return !isEqual(Object.values(curr)[0], Object.values(next)[0]);
}
function validateComponentsDifference(files) {
    let isDiffer = false;
    for (let i = 0, len = files.length; i < len; i++) {
        let next = files[i + 1];
        if (next && doesComponentsDiffer(files[i], next)) {
            isDiffer = true;
        }
    }
    return isDiffer;
}
function iteratePotentialConflicts(potentialConflicts) {
    for (const group of Object.keys(potentialConflicts)) {
        for (const [key, value] of Object.entries(potentialConflicts[group])) {
            const conflicts = filterConflicts(value);
            if (conflicts.length) {
                if (group === COMPONENTS) {
                    for (const [_, conflict] of Object.entries(conflicts)) {
                        if (validateComponentsDifference(conflict[1])) {
                            conflict[1] = conflict[1].map((c) => Object.keys(c)[0]);
                            showConflicts(colorette_1.green(group) + ' => ' + key, [conflict]);
                            potentialConflictsTotal += 1;
                        }
                    }
                }
                else {
                    showConflicts(colorette_1.green(group) + ' => ' + key, conflicts);
                    potentialConflictsTotal += conflicts.length;
                }
                prefixTagSuggestion(group, conflicts.length);
            }
        }
    }
}
function prefixTagSuggestion(group, conflictsLength) {
    if (group === 'tags') {
        process.stderr.write(colorette_1.green(`
    ${conflictsLength} conflict(s) on tags.
    Suggestion: please use ${colorette_1.blue('prefix-tags-with-filename')} or ${colorette_1.blue('prefix-tags-with-info-prop')} to prevent naming conflicts. \n\n`));
    }
}
function showConflicts(key, conflicts) {
    for (const [path, files] of conflicts) {
        process.stderr.write(colorette_1.yellow(`Conflict on ${key} : ${colorette_1.red(path)} in files: ${colorette_1.blue(files)} \n`));
    }
}
function filterConflicts(entities) {
    return Object.entries(entities).filter(([_, files]) => files.length > 1);
}
function getEntrypointFilename(filePath) {
    return path.basename(filePath, path.extname(filePath));
}
function addPrefix(tag, tagsPrefix) {
    return tagsPrefix ? tagsPrefix + '_' + tag : tag;
}
function formatTags(tags) {
    return tags.map((tag) => ({ name: tag }));
}
function addComponentsPrefix(description, componentsPrefix) {
    return description.replace(/"(#\/components\/.*?)"/g, (match) => {
        const componentName = path.basename(match);
        return match.replace(componentName, addPrefix(componentName, componentsPrefix));
    });
}
function addSecurityPrefix(security, componentsPrefix) {
    return componentsPrefix ? security === null || security === void 0 ? void 0 : security.map((s) => {
        const key = Object.keys(s)[0];
        return { [componentsPrefix + '_' + key]: s[key] };
    }) : security;
}
function getInfoPrefix(info, prefixArg, type) {
    if (!prefixArg)
        return '';
    if (!info)
        utils_1.exitWithError('Info section is not found in specification. \n');
    if (!info[prefixArg])
        utils_1.exitWithError(`${colorette_1.yellow(`prefix-${type}-with-info-prop`)} argument value is not found in info section. \n`);
    if (!js_utils_1.isString(info[prefixArg]))
        utils_1.exitWithError(`${colorette_1.yellow(`prefix-${type}-with-info-prop`)} argument value should be string. \n\n`);
    if (info[prefixArg].length > 50)
        utils_1.exitWithError(`${colorette_1.yellow(`prefix-${type}-with-info-prop`)} argument value length should not exceed 50 characters. \n\n`);
    return info[prefixArg];
}
function validateEntrypoint(document, config, externalRefResolver, packageVersion) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const results = yield openapi_core_1.lintDocument({ document, config, externalRefResolver });
            const fileTotals = utils_1.getTotals(results);
            openapi_core_1.formatProblems(results, { format: 'stylish', totals: fileTotals, version: packageVersion });
            utils_1.printLintTotals(fileTotals, 2);
        }
        catch (err) {
            utils_1.handleError(err, document.parsed);
        }
    });
}
function crawl(object, visitor) {
    if (!js_utils_1.isObject(object))
        return;
    for (const key of Object.keys(object)) {
        visitor(object, key);
        crawl(object[key], visitor);
    }
}
function replace$Refs(obj, componentsPrefix) {
    crawl(obj, (node) => {
        if (node.$ref && js_utils_1.isString(node.$ref) && node.$ref.startsWith(`#/${COMPONENTS}/`)) {
            const name = path.basename(node.$ref);
            node.$ref = node.$ref.replace(name, componentsPrefix + '_' + name);
        }
        else if (node.discriminator &&
            node.discriminator.mapping &&
            js_utils_1.isObject(node.discriminator.mapping)) {
            const { mapping } = node.discriminator;
            for (const name of Object.keys(mapping)) {
                if (js_utils_1.isString(mapping[name]) && mapping[name].startsWith(`#/${COMPONENTS}/`)) {
                    mapping[name] = mapping[name].split('/').map((name, i, arr) => {
                        return (arr.length - 1 === i && !name.includes(componentsPrefix)) ? componentsPrefix + '_' + name : name;
                    }).join('/');
                }
            }
        }
    });
}

"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleBundle = void 0;
const openapi_core_1 = require("@redocly/openapi-core");
const utils_1 = require("../utils");
const perf_hooks_1 = require("perf_hooks");
const colorette_1 = require("colorette");
function handleBundle(argv, version) {
    return __awaiter(this, void 0, void 0, function* () {
        const config = yield openapi_core_1.loadConfig(argv.config);
        config.lint.skipRules(argv['skip-rule']);
        config.lint.skipPreprocessors(argv['skip-preprocessor']);
        config.lint.skipDecorators(argv['skip-decorator']);
        const entrypoints = yield utils_1.getFallbackEntryPointsOrExit(argv.entrypoints, config);
        const totals = { errors: 0, warnings: 0, ignored: 0 };
        for (const entrypoint of entrypoints) {
            try {
                const startedAt = perf_hooks_1.performance.now();
                process.stderr.write(colorette_1.gray(`bundling ${entrypoint}...\n`));
                const { bundle: result, problems } = yield openapi_core_1.bundle({
                    config,
                    ref: entrypoint,
                    dereference: argv.dereferenced,
                });
                const fileTotals = utils_1.getTotals(problems);
                const { outputFile, ext } = utils_1.getOutputFileName(entrypoint, entrypoints.length, argv.output, argv.ext);
                if (fileTotals.errors === 0 || argv.force) {
                    if (!argv.output) {
                        const output = utils_1.dumpBundle(result.parsed, argv.ext || 'yaml', argv.dereferenced);
                        process.stdout.write(output);
                    }
                    else {
                        const output = utils_1.dumpBundle(result.parsed, ext, argv.dereferenced);
                        utils_1.saveBundle(outputFile, output);
                    }
                }
                totals.errors += fileTotals.errors;
                totals.warnings += fileTotals.warnings;
                totals.ignored += fileTotals.ignored;
                openapi_core_1.formatProblems(problems, {
                    format: argv.format,
                    maxProblems: argv['max-problems'],
                    totals: fileTotals,
                    version,
                });
                const elapsed = utils_1.getExecutionTime(startedAt);
                if (fileTotals.errors > 0) {
                    if (argv.force) {
                        process.stderr.write(`‚ùì Created a bundle for ${colorette_1.blue(entrypoint)} at ${colorette_1.blue(outputFile)} with errors ${colorette_1.green(elapsed)}.\n${colorette_1.yellow('Errors ignored because of --force')}.\n`);
                    }
                    else {
                        process.stderr.write(`‚ùå Errors encountered while bundling ${colorette_1.blue(entrypoint)}: bundle not created (use --force to ignore errors).\n`);
                    }
                }
                else {
                    process.stderr.write(`üì¶ Created a bundle for ${colorette_1.blue(entrypoint)} at ${colorette_1.blue(outputFile)} ${colorette_1.green(elapsed)}.\n`);
                }
            }
            catch (e) {
                utils_1.handleError(e, entrypoint);
            }
        }
        utils_1.printUnusedWarnings(config.lint);
        process.exit(totals.errors === 0 || argv.force ? 0 : 1);
    });
}
exports.handleBundle = handleBundle;

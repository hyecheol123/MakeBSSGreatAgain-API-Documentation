#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
require("./assert-node-version");
const yargs = require("yargs");
const colorette_1 = require("colorette");
const utils_1 = require("./utils");
const types_1 = require("./types");
const openapi_core_1 = require("@redocly/openapi-core");
const preview_docs_1 = require("./commands/preview-docs");
const stats_1 = require("./commands/stats");
const split_1 = require("./commands/split");
const join_1 = require("./commands/join");
const push_1 = require("./commands/push");
const lint_1 = require("./commands/lint");
const bundle_1 = require("./commands/bundle");
const version = require('../package.json').version;
yargs
    .version('version', 'Show version number.', version)
    .help('help', 'Show help.')
    .command('stats [entrypoint]', 'Gathering statistics for a document.', (yargs) => yargs
    .positional('entrypoint', { type: 'string' })
    .option({
    config: { description: 'Specify path to the config file.', type: 'string' },
    format: {
        description: 'Use a specific output format.',
        choices: ['stylish', 'json'],
        default: 'stylish',
    }
}), (argv) => { stats_1.handleStats(argv); })
    .command('split [entrypoint]', 'Split definition into a multi-file structure.', (yargs) => yargs
    .positional('entrypoint', { type: 'string' })
    .option({
    outDir: {
        description: 'Output directory where files will be saved.',
        required: true,
        type: 'string'
    }
}), (argv) => { split_1.handleSplit(argv); })
    .command('join [entrypoints...]', 'Join definitions [experimental].', (yargs) => yargs
    .positional('entrypoints', {
    array: true,
    type: 'string',
    demandOption: true
})
    .option({
    lint: { description: 'Lint definitions', type: 'boolean', default: false },
    'prefix-tags-with-info-prop': {
        description: 'Prefix tags with property value from info object.',
        requiresArg: true,
        type: 'string',
    },
    'prefix-tags-with-filename': {
        description: 'Prefix tags with property value from file name.',
        type: 'boolean',
        default: false
    },
    'prefix-components-with-info-prop': {
        description: 'Prefix components with property value from info object.',
        requiresArg: true,
        type: 'string',
    }
}), (argv) => { join_1.handleJoin(argv, version); })
    .command('push <entrypoint> <destination> [branchName]', 'Push an API definition to the Redocly API registry.', (yargs) => yargs
    .positional('entrypoint', { type: 'string' })
    .positional('destination', { type: 'string' })
    .positional('branchName', { type: 'string' })
    .option({
    'upsert': { type: 'boolean', alias: 'u' },
    'run-id': { type: 'string', requiresArg: true }
}), (argv) => { push_1.handlePush(argv); })
    .command('lint [entrypoints...]', 'Lint definition.', (yargs) => yargs
    .positional('entrypoints', { array: true, type: 'string', demandOption: true })
    .option({
    format: {
        description: 'Use a specific output format.',
        choices: ['stylish', 'codeframe', 'json'],
        default: 'codeframe',
    },
    'max-problems': {
        requiresArg: true,
        description: 'Reduce output to max N problems.',
        type: 'number',
        default: 100,
    },
    'generate-ignore-file': {
        description: 'Generate ignore file.',
        type: 'boolean',
    },
    'skip-rule': {
        description: 'Ignore certain rules.',
        array: true,
        type: 'string',
    },
    'skip-preprocessor': {
        description: 'Ignore certain preprocessors.',
        array: true,
        type: 'string',
    },
    config: {
        description: 'Specify path to the config file.',
        requiresArg: true,
        type: 'string',
    },
    extends: {
        description: 'Override extends configurations (defaults or config file settings).',
        requiresArg: true,
        array: true,
        type: 'string',
    }
}), (argv) => { lint_1.handleLint(argv, version); })
    .command('bundle [entrypoints...]', 'Bundle definition.', (yargs) => yargs
    .positional('entrypoints', { array: true, type: 'string', demandOption: true })
    .options({
    output: { type: 'string', alias: 'o' },
    format: {
        description: 'Use a specific output format.',
        choices: ['stylish', 'codeframe', 'json'],
        default: 'codeframe',
    },
    'max-problems': {
        requiresArg: true,
        description: 'Reduce output to max N problems.',
        type: 'number',
        default: 100,
    },
    ext: {
        description: 'Bundle file extension.',
        requiresArg: true,
        choices: types_1.outputExtensions,
    },
    'skip-rule': {
        description: 'Ignore certain rules.',
        array: true,
        type: 'string',
    },
    'skip-preprocessor': {
        description: 'Ignore certain preprocessors.',
        array: true,
        type: 'string',
    },
    'skip-decorator': {
        description: 'Ignore certain decorators.',
        array: true,
        type: 'string',
    },
    dereferenced: {
        alias: 'd',
        type: 'boolean',
        description: 'Produce fully dereferenced bundle.',
    },
    force: {
        alias: 'f',
        type: 'boolean',
        description: 'Produce bundle output even when errors occur.',
    },
    config: {
        description: 'Specify path to the config file.',
        type: 'string',
    }
}), (argv) => { bundle_1.handleBundle(argv, version); })
    .command('login', 'Login to the Redocly API registry with an access token.', () => __awaiter(void 0, void 0, void 0, function* () {
    const clientToken = yield utils_1.promptUser(colorette_1.green(`\n  ðŸ”‘ Copy your access token from ${colorette_1.blue(`https://app.${process.env.REDOCLY_DOMAIN || 'redoc.ly'}/profile`)} and paste it below`));
    const client = new openapi_core_1.RedoclyClient();
    client.login(clientToken);
}))
    .command('logout', 'Clear your stored credentials for the Redocly API registry.', () => __awaiter(void 0, void 0, void 0, function* () {
    const client = new openapi_core_1.RedoclyClient();
    client.logout();
}))
    .command('preview-docs [entrypoint]', 'Preview API reference docs for the specified definition.', (yargs) => yargs
    .positional('entrypoint', { type: 'string' })
    .options({
    port: {
        alias: 'p',
        type: 'number',
        default: 8080,
        description: 'Preview port.'
    },
    'skip-preprocessor': {
        description: 'Ignore certain preprocessors.',
        array: true,
        type: 'string',
    },
    'skip-decorator': {
        description: 'Ignore certain decorators.',
        array: true,
        type: 'string',
    },
    'use-community-edition': {
        description: 'Force using Redoc CE for docs preview.',
        type: 'boolean',
    },
    'force': {
        alias: 'f',
        type: 'boolean',
        description: 'Produce bundle output even when errors occur.',
    },
    'config': {
        description: 'Specify path to the config file.',
        type: 'string',
    }
}), (argv) => __awaiter(void 0, void 0, void 0, function* () { preview_docs_1.previewDocs(argv); }))
    .demandCommand(1)
    .strict().argv;

"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.slash = exports.exitWithError = exports.printUnusedWarnings = exports.getOutputFileName = exports.printLintTotals = exports.handleError = exports.pluralize = exports.writeYaml = exports.readYaml = exports.promptUser = exports.saveBundle = exports.dumpBundle = exports.CircularJSONNotSupportedError = exports.pathToFilename = exports.printExecutionTime = exports.getExecutionTime = exports.getTotals = exports.getFallbackEntryPointsOrExit = void 0;
const path_1 = require("path");
const colorette_1 = require("colorette");
const perf_hooks_1 = require("perf_hooks");
const glob = require("glob-promise");
const yaml = require("js-yaml");
const fs = require("fs");
const path = require("path");
const readline = require("readline");
const openapi_core_1 = require("@redocly/openapi-core");
const types_1 = require("./types");
function getFallbackEntryPointsOrExit(argsEntrypoints, config) {
    return __awaiter(this, void 0, void 0, function* () {
        const { apiDefinitions } = config;
        const shouldFallbackToAllDefinitions = !isNotEmptyArray(argsEntrypoints) && apiDefinitions && Object.keys(apiDefinitions).length > 0;
        const res = shouldFallbackToAllDefinitions
            ? Object.values(apiDefinitions).map((fileName) => path_1.resolve(getConfigDirectory(config), fileName))
            : yield expandGlobsInEntrypoints(argsEntrypoints, config);
        if (!isNotEmptyArray(res)) {
            process.stderr.write('error: missing required argument `entrypoints`.\n');
            process.exit(1);
        }
        return res;
    });
}
exports.getFallbackEntryPointsOrExit = getFallbackEntryPointsOrExit;
function getConfigDirectory(config) {
    return config.configFile ? path_1.dirname(config.configFile) : process.cwd();
}
function isNotEmptyArray(args) {
    return Array.isArray(args) && !!args.length;
}
function getAliasOrPath(config, aliasOrPath) {
    return config.apiDefinitions[aliasOrPath] || aliasOrPath;
}
function expandGlobsInEntrypoints(args, config) {
    return __awaiter(this, void 0, void 0, function* () {
        return (yield Promise.all(args.map((aliasOrPath) => __awaiter(this, void 0, void 0, function* () {
            return glob.hasMagic(aliasOrPath)
                ? (yield glob(aliasOrPath)).map((g) => getAliasOrPath(config, g))
                : getAliasOrPath(config, aliasOrPath);
        })))).flat();
    });
}
function getTotals(problems) {
    let errors = 0;
    let warnings = 0;
    let ignored = 0;
    for (const m of problems) {
        if (m.ignored) {
            ignored++;
            continue;
        }
        if (m.severity === 'error')
            errors++;
        if (m.severity === 'warn')
            warnings++;
    }
    return {
        errors,
        warnings,
        ignored,
    };
}
exports.getTotals = getTotals;
function getExecutionTime(startedAt) {
    return process.env.NODE_ENV === 'test'
        ? '<test>ms'
        : `${Math.ceil(perf_hooks_1.performance.now() - startedAt)}ms`;
}
exports.getExecutionTime = getExecutionTime;
function printExecutionTime(commandName, startedAt, entrypoint) {
    const elapsed = getExecutionTime(startedAt);
    process.stderr.write(colorette_1.gray(`\n${entrypoint}: ${commandName} processed in ${elapsed}\n\n`));
}
exports.printExecutionTime = printExecutionTime;
function pathToFilename(path) {
    return path
        .replace(/~1/g, '/')
        .replace(/~0/g, '~')
        .substring(1)
        .replace(/\//g, '@');
}
exports.pathToFilename = pathToFilename;
class CircularJSONNotSupportedError extends Error {
    constructor(originalError) {
        super(originalError.message);
        this.originalError = originalError;
        // Set the prototype explicitly.
        Object.setPrototypeOf(this, CircularJSONNotSupportedError.prototype);
    }
}
exports.CircularJSONNotSupportedError = CircularJSONNotSupportedError;
function dumpBundle(obj, format, dereference) {
    if (format === 'json') {
        try {
            return JSON.stringify(obj, null, 2);
        }
        catch (e) {
            if (e.message.indexOf('circular') > -1) {
                throw new CircularJSONNotSupportedError(e);
            }
            throw e;
        }
    }
    else {
        return yaml.safeDump(obj, {
            noRefs: !dereference,
        });
    }
}
exports.dumpBundle = dumpBundle;
function saveBundle(filename, output) {
    fs.mkdirSync(path.dirname(filename), { recursive: true });
    fs.writeFileSync(filename, output);
}
exports.saveBundle = saveBundle;
function promptUser(query) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve) => {
            const rl = readline.createInterface({
                input: process.stdin,
                output: process.stdout,
            });
            rl.question(`${query}:\n\n  `, (answer) => {
                rl.close();
                resolve(answer);
            });
        });
    });
}
exports.promptUser = promptUser;
function readYaml(filename) {
    return yaml.safeLoad(fs.readFileSync(filename, 'utf-8'), { filename });
}
exports.readYaml = readYaml;
function writeYaml(data, filename, noRefs = false) {
    return fs.writeFileSync(filename, yaml.safeDump(data, { noRefs }));
}
exports.writeYaml = writeYaml;
function pluralize(label, num) {
    if (label.endsWith('is')) {
        [label] = label.split(' ');
        return num === 1 ? `${label} is` : `${label}s are`;
    }
    return num === 1 ? `${label}` : `${label}s`;
}
exports.pluralize = pluralize;
function handleError(e, ref) {
    if (e instanceof openapi_core_1.ResolveError) {
        process.stderr.write(`Failed to resolve entrypoint definition at ${ref}:\n\n  - ${e.message}.\n\n`);
    }
    else if (e instanceof openapi_core_1.YamlParseError) {
        process.stderr.write(`Failed to parse entrypoint definition at ${ref}:\n\n  - ${e.message}.\n\n`);
        // TODO: codeframe
    }
    else { // @ts-ignore
        if (e instanceof CircularJSONNotSupportedError) {
            process.stderr.write(colorette_1.red(`Detected circular reference which can't be converted to JSON.\n`) +
                `Try to use ${colorette_1.blue('yaml')} output or remove ${colorette_1.blue('--dereferenced')}.\n\n`);
        }
        else {
            process.stderr.write(`Something went wrong when processing ${ref}:\n\n  - ${e.message}.\n\n`);
            throw e;
        }
    }
}
exports.handleError = handleError;
function printLintTotals(totals, definitionsCount) {
    const ignored = totals.ignored
        ? colorette_1.yellow(`${totals.ignored} ${pluralize('problem is', totals.ignored)} explicitly ignored.\n\n`)
        : '';
    if (totals.errors > 0) {
        process.stderr.write(colorette_1.red(`âŒ Validation failed with ${totals.errors} ${pluralize('error', totals.errors)}${totals.warnings > 0
            ? ` and ${totals.warnings} ${pluralize('warning', totals.warnings)}`
            : ''}.\n${ignored}`));
    }
    else if (totals.warnings > 0) {
        process.stderr.write(colorette_1.green(`Woohoo! Your OpenAPI ${pluralize('definition is', definitionsCount)} valid. ðŸŽ‰\n`));
        process.stderr.write(colorette_1.yellow(`You have ${totals.warnings} ${pluralize('warning', totals.warnings)}.\n${ignored}`));
    }
    else {
        process.stderr.write(colorette_1.green(`Woohoo! Your OpenAPI ${pluralize('definition is', definitionsCount)} valid. ðŸŽ‰\n${ignored}`));
    }
    if (totals.errors > 0) {
        process.stderr.write(colorette_1.gray(`run with \`--generate-ignore-file\` to add all problems to ignore file.\n`));
    }
    process.stderr.write('\n');
}
exports.printLintTotals = printLintTotals;
function getOutputFileName(entrypoint, entries, output, ext) {
    if (!output) {
        return { outputFile: 'stdout', ext: ext || 'yaml' };
    }
    let outputFile = output;
    if (entries > 1) {
        ext = ext || path_1.extname(entrypoint).substring(1);
        if (!types_1.outputExtensions.includes(ext)) {
            throw new Error(`Invalid file extension: ${ext}.`);
        }
        outputFile = path_1.join(output, path_1.basename(entrypoint, path_1.extname(entrypoint))) + '.' + ext;
    }
    else {
        if (output) {
            ext = ext || path_1.extname(output).substring(1);
        }
        ext = ext || path_1.extname(entrypoint).substring(1);
        if (!types_1.outputExtensions.includes(ext)) {
            throw new Error(`Invalid file extension: ${ext}.`);
        }
        outputFile = path_1.join(path_1.dirname(outputFile), path_1.basename(outputFile, path_1.extname(outputFile))) + '.' + ext;
    }
    return { outputFile, ext };
}
exports.getOutputFileName = getOutputFileName;
function printUnusedWarnings(config) {
    const { preprocessors, rules, decorators } = config.getUnusedRules();
    if (rules.length) {
        process.stderr.write(colorette_1.yellow(`[WARNING] Unused rules found in ${colorette_1.blue(config.configFile || '')}: ${rules.join(', ')}.\n`));
    }
    if (preprocessors.length) {
        process.stderr.write(colorette_1.yellow(`[WARNING] Unused preprocessors found in ${colorette_1.blue(config.configFile || '')}: ${preprocessors.join(', ')}.\n`));
    }
    if (decorators.length) {
        process.stderr.write(colorette_1.yellow(`[WARNING] Unused decorators found in ${colorette_1.blue(config.configFile || '')}: ${decorators.join(', ')}.\n`));
    }
    if (rules.length || preprocessors.length) {
        process.stderr.write(`Check the spelling and verify you added plugin prefix.\n`);
    }
}
exports.printUnusedWarnings = printUnusedWarnings;
function exitWithError(message) {
    process.stderr.write(colorette_1.red(message) + '\n\n');
    process.exit(1);
}
exports.exitWithError = exitWithError;
/**
 * Convert Windows backslash paths to slash paths: foo\\bar âž” foo/bar
 */
function slash(path) {
    const isExtendedLengthPath = /^\\\\\?\\/.test(path);
    if (isExtendedLengthPath) {
        return path;
    }
    return path.replace(/\\/g, '/');
}
exports.slash = slash;

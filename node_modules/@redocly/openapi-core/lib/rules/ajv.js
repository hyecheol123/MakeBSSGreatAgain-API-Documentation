"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateJsonSchema = exports.releaseAjvInstance = void 0;
// @ts-ignore
const Ajv = require("@redocly/ajv");
// import * as jsonSpecV4 from 'ajv/lib/refs/json-schema-draft-04.json';
// import { OasVersion } from '../validate';
const ref_utils_1 = require("../ref-utils");
let ajvInstance = null;
function releaseAjvInstance() {
    ajvInstance = null;
}
exports.releaseAjvInstance = releaseAjvInstance;
function getAjv(resolve, disallowAdditionalProperties) {
    if (!ajvInstance) {
        ajvInstance = new Ajv({
            schemaId: 'auto',
            meta: true,
            allErrors: true,
            jsonPointers: true,
            unknownFormats: 'ignore',
            nullable: true,
            missingRefs: 'ignore',
            inlineRefs: false,
            validateSchema: false,
            defaultAdditionalProperties: !disallowAdditionalProperties,
            loadSchemaSync(base, $ref, id) {
                const resolvedRef = resolve({ $ref }, base.replace(/#$/, ''));
                if (!resolvedRef || !resolvedRef.location)
                    return undefined;
                return Object.assign({ id }, resolvedRef.node);
            },
            logger: false,
        });
    }
    return ajvInstance;
}
function getAjvValidator(schema, loc, resolve, disallowAdditionalProperties) {
    const ajv = getAjv(resolve, disallowAdditionalProperties);
    if (!ajv.getSchema(loc.absolutePointer)) {
        ajv.addSchema(Object.assign({ id: loc.absolutePointer }, schema), loc.absolutePointer);
    }
    return ajv.getSchema(loc.absolutePointer);
}
function validateJsonSchema(data, schema, schemaLoc, dataPath, resolve, disallowAdditionalProperties) {
    const validate = getAjvValidator(schema, schemaLoc, resolve, disallowAdditionalProperties);
    if (!validate)
        return { valid: true, errors: [] }; // unresolved refs are reported
    const valid = validate(data, dataPath);
    return {
        valid: !!valid,
        errors: (validate.errors || []).map(beatifyErrorMessage),
    };
    function beatifyErrorMessage(error) {
        let message = error.message;
        let suggest = error.keyword === 'enum' ? error.params.allowedValues : undefined;
        if (suggest) {
            message += ` ${suggest.map((e) => `"${e}"`).join(', ')}`;
        }
        if (error.keyword === 'type') {
            message = `type ${message}`;
        }
        const relativePath = error.dataPath.substring(dataPath.length + 1);
        const propName = relativePath.substring(relativePath.lastIndexOf('/') + 1);
        if (propName) {
            message = `\`${propName}\` property ${message}`;
        }
        if (error.keyword === 'additionalProperties') {
            const property = error.params.additionalProperty;
            message = `${message} \`${property}\``;
            error.dataPath += '/' + ref_utils_1.escapePointer(property);
        }
        return Object.assign(Object.assign({}, error), { message,
            suggest });
    }
}
exports.validateJsonSchema = validateJsonSchema;
